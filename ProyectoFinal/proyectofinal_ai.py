# -*- coding: utf-8 -*-
"""ProyectoFinal_AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Xy8vwWH6TDSnlWqiq67RApdARyFnjWCB

#Proyecto Final - Predicciones de Aceptación en Ingeniería

## Importe de Librerias
"""

##Librerias
import pandas as pd # Para manipular datos
import numpy as np # Para multiplicaciÓn entre matrices
from sklearn.preprocessing import StandardScaler # Para la seccion de preprocesamiento
from sklearn.model_selection import train_test_split # Para distribuir los datos del dataset en datos de entrenamiento y datos de prueba

from sklearn.metrics import matthews_corrcoef # Para el Coeficiente de relacion de Matthews
from sklearn.metrics import f1_score # Para el F-score balanceado o F-medida
from sklearn.metrics import accuracy_score # Para el Accuracy 
from sklearn.metrics import roc_curve,roc_auc_score # Para realizar la curva ROC

from sklearn.linear_model import LogisticRegression # Para reesion Logalizar el algoritmo de Regristica

import matplotlib.pyplot as plt # Para la creacion de Graficas
from matplotlib.colors import ListedColormap # Para asignar colores a las graficas
import matplotlib.patches as mpatches # Para crear circulos en las graficas

"""##Importe de Dataset"""

#Importe de datos 
dataFrame = pd.read_csv('DatosModificados.csv', delimiter=';') # se importa el archivo con los datos a trabajar
#print(dataFrame.columns) # se imprime el analisis del archivo en un formato de columnas 
#print(dataFrame.dtypes) #se imprime el tipo de datos que tiene el archivo en cuestion
dataFrame.head(5) # Se observan los primeros 5 datos de la tabla

"""## Ajustes/Procesamiento del Dataset"""

# Casting de los datos a numpy matrix/array para un mejor manejo
matriz=np.asarray(dataFrame, dtype=int)
x = matriz[:,:7] # Seleccion de Caracteristicas
y = matriz[:,7] # Seleccion de Etiquetas
print("Caracteristicas",x)
print("Etiquetas",y)
print(type(y))

x_train, x_test, y_train, y_test = train_test_split(x, y,test_size=0.2, random_state=0) # Se Realiza la distribucion de datos entre entrenamiento y prueba
scaler = StandardScaler() # Se usa el preprocesamiento para quitar la media y escalar los datos a una varianza unitaria
scaler.fit(x_train) # El fit se realiza para los datos de entrenamiento 

# Se transforman los datos centrandolos en cero y escalandolos, para luego ser usados
x_train = scaler.transform(x_train) 
x_test = scaler.transform(x_test)

#Para verificar la distribucion de los datos entre test y train
#print(x_train[:5,])
#print("forma x=",x.shape)
#print("forma y=",y.shape)
#print("forma x_train=",x_train.shape)
#print("forma y_train=",y_train.shape)
#print("forma x_test=",x_test.shape)
#print("forma y_test=",y_test.shape)

"""##Implementación del Algoritmo: Regresión Logística con Regularización y sus Métricas"""

# Uso del ALgoritmo de regresion Logistica por Regularizacion e implementacion de las metricas
#                   start  stop step
LRrange = np.arange(0.0001,0.01,0.001) # se crea un arreglo de valores para variar el hiperparametro C en linear_model LogisticRegression, Hiperparametro de regularizacion

# Se crea una lista para la mas metricas 
ACC=[]
MCC=[]
F1_micro=[]
F1_macro=[]

# Se crea el loop para variar el hiperparametro
for k in LRrange:    
    LR = LogisticRegression(penalty='l2', tol=1e-14, C=k, solver='saga', max_iter=10000, multi_class='auto', class_weight='balanced')
    LR = LR.fit(x_train, y_train)

    ytest_predicted = LR.predict(x_test)
    ytrain_predicted = LR.predict(x_train)
    ytest_scores = LR.predict_proba(x_test)

    # A continuación, se realiza el cálculo de las metricas
    print("Iteracion=", k)
    MCC.append(matthews_corrcoef(y_test, ytest_predicted))
    print("matthews_corrcoef=", MCC)
    ACC.append(accuracy_score(y_test, ytest_predicted))
    print("Accuracy= ", ACC)
    #F1_micro 
    F1_micro.append(f1_score(y_test,ytest_predicted,average='micro'))
    print("F1_micro= ",F1_micro)
    #F1_macro
    F1_macro.append(f1_score(y_test,ytest_predicted,average='macro'))
    print("F1_macro= ",F1_macro, "\n")
    #Curva ROC
    fpr,tpr,thresholds = roc_curve(y_test, ytest_scores[:,1]) # fpr=FalsePositiveRate, tpr= TruePositiveRate
    roc_auc = roc_auc_score(y_test, ytest_scores[:,1])
    plt.figure()
    lw = 2
    plt.plot(fpr, tpr, color='darkorange',lw=lw, label='ROC curve (area = %0.4f)' % roc_auc)
    plt.plot([0, 1], [0, 1], color='navy', lw=lw, linestyle='--')
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')
    plt.title('Receiver Operating Characteristic-->ROC')
    plt.legend(loc="lower right")
    plt.show()

"""## Grafico/Mapas de color - Datos Entrenamiento"""

# Creacion del grafico/mapa de entrenamiento
X=x_train
y=y_train

idx1=2
idx2=3
h = .02  # Step/Pasos en la malla a ser creada

# Colores para le mapa
cmap_light = ListedColormap(['#FFAAAA', '#b3ffff'])#['#FFAAAA', '#ffcc99', '#ffffb3','#b3ffff','#c2f0c2']
cmap_bold = ListedColormap(['#FF0000', '#00ffff'])#['#FF0000', '#ff9933','#FFFF00','#00ffff','#00FF00']
 
# Se grafica la frontera de decision, Se asigna un color a cada punto en la malla [x_min, x_max]x[y_min, y_max].
x_min, x_max = X[:, idx1].min() - 1, X[:, idx1].max() + 1
y_min, y_max = X[:, idx2].min() - 1, X[:, idx2].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
# Se usa el algoritmo de regresion logistica, creando nuestra propia hipotesis
Z = LR.predict(np.c_[np.zeros_like(xx.ravel()),
                     xx.ravel()* yy.ravel(),
                     xx.ravel()*xx.ravel(),
                     yy.ravel()*yy.ravel(),
                     yy.ravel()*yy.ravel()* yy.ravel(),
                     xx.ravel()*xx.ravel()*xx.ravel()*xx.ravel(),
                     yy.ravel()*yy.ravel()* yy.ravel()* yy.ravel()])

# Se pasan los resultados del algoritmo a una grafica a color
Z = Z.reshape(xx.shape)
plt.figure()
plt.pcolormesh(xx, yy, Z, cmap=cmap_light)
 
# Plot also the training points
plt.scatter(X[:, idx1], X[:, idx2], c=y, cmap=cmap_bold,
                edgecolor='k', s=60)
plt.xlim(xx.min(), xx.max())
plt.ylim(yy.min(), yy.max())
    
patch0 = mpatches.Patch(color='#FF0000', label='0')
patch1 = mpatches.Patch(color='#00ffff', label='1')
plt.legend(handles=[patch0, patch1])
 
    
plt.title("Resultado regresión logistica training %s")
 
plt.show()

"""## Grafico/Mapas de color - Datos Prueba"""

# Creacion del grafico/mapa de prueba
X=x_test
y=y_test

idx1=2
idx2=3
h = .02  # Step/Pasos en la malla a ser creada

# Colores para le mapa
cmap_light = ListedColormap(['#FFAAAA', '#b3ffff'])#['#FFAAAA', '#ffcc99', '#ffffb3','#b3ffff','#c2f0c2']
cmap_bold = ListedColormap(['#FF0000', '#00ffff'])#['#FF0000', '#ff9933','#FFFF00','#00ffff','#00FF00']
 
# Se grafica la frontera de decision, Se asigna un color a cada punto en la malla [x_min, x_max]x[y_min, y_max].
x_min, x_max = X[:, idx1].min() - 1, X[:, idx1].max() + 1
y_min, y_max = X[:, idx2].min() - 1, X[:, idx2].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                         np.arange(y_min, y_max, h))
# Se usa el algoritmo de regresion logistica, creando nuestra propia hipotesis
Z = LR.predict(np.c_[np.zeros_like(xx.ravel()),
                     xx.ravel()* yy.ravel(),
                     xx.ravel()*xx.ravel(),
                     yy.ravel()* yy.ravel(),
                     yy.ravel()*yy.ravel()* yy.ravel(),
                     xx.ravel()*xx.ravel()*xx.ravel()*xx.ravel(),
                     yy.ravel()*yy.ravel()* yy.ravel()* yy.ravel()])

# Se pasan los resultados del algoritmo a una grafica a color
Z = Z.reshape(xx.shape)
plt.figure()
plt.pcolormesh(xx, yy, Z, cmap=cmap_light)
 
# Plot also the training points
plt.scatter(X[:, idx1], X[:, idx2], c=y, cmap=cmap_bold,
                edgecolor='k', s=60)
plt.xlim(xx.min(), xx.max())
plt.ylim(yy.min(), yy.max())
    
patch0 = mpatches.Patch(color='#FF0000', label='0')
patch1 = mpatches.Patch(color='#00ffff', label='1')
plt.legend(handles=[patch0, patch1])
 
    
plt.title("Resultado regresión logistica testing")
 
plt.show()